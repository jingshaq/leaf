#include <ntddk.h>

#define PIPE_NAME L"\\Device\\MyNamedPipe"
#define BUFFER_SIZE 512

PFILE_OBJECT g_pPipeFileObject = NULL;
KEVENT g_ExitEvent;
LIST_ENTRY g_DataList;
KSPIN_LOCK g_DataListLock;

// 结构体用于链表中存储数据
typedef struct _DATA_ITEM {
    LIST_ENTRY ListEntry;
    WCHAR Data[BUFFER_SIZE];
} DATA_ITEM;

VOID ReceiveThread(PVOID StartContext) {
    UNREFERENCED_PARAMETER(StartContext);

    LARGE_INTEGER timeout;
    timeout.QuadPart = -10000000;  // 1秒的相对时间

    while (TRUE) {
        // 在这里实现从用户层读取数据并处理的逻辑
        // 你需要使用ZwReadFile函数或其他适当的方法来从管道读取数据

        // 检查是否需要退出线程
        if (KeReadStateEvent(&g_ExitEvent) != 0) {
            break;
        }
    }
}

VOID SendThread(PVOID StartContext) {
    UNREFERENCED_PARAMETER(StartContext);

    while (TRUE) {
        // 在这里实现将数据发送到用户层的逻辑
        // 你需要使用ZwWriteFile函数或其他适当的方法来向管道写入数据

        // 检查是否需要退出线程
        if (KeReadStateEvent(&g_ExitEvent) != 0) {
            break;
        }
    }
}

// 在其他地方将数据添加到链表中，例如在驱动程序中
VOID AddDataToQueue(WCHAR* data) {
    DATA_ITEM* dataItem = ExAllocatePool(NonPagedPool, sizeof(DATA_ITEM));
    if (dataItem != NULL) {
        RtlCopyMemory(dataItem->Data, data, sizeof(dataItem->Data));

        KIRQL irql;
        KeAcquireSpinLock(&g_DataListLock, &irql);
        InsertTailList(&g_DataList, &dataItem->ListEntry);
        KeReleaseSpinLock(&g_DataListLock, irql);
    }
}

// 驱动程序初始化中创建线程和命名管道
NTSTATUS DriverEntry(PDRIVER_OBJECT pDriverObject, PUNICODE_STRING pRegistryPath) {
    // 创建命名管道
    NTSTATUS status = CreateNamedPipe();
    if (!NT_SUCCESS(status)) {
        KdPrint(("Failed to create named pipe.\n"));
        return status;
    }

    // 创建链表
    InitializeListHead(&g_DataList);
    KeInitializeSpinLock(&g_DataListLock);

    // 创建接收线程
    HANDLE receiveThreadHandle;
    status = PsCreateSystemThread(&receiveThreadHandle, THREAD_ALL_ACCESS, NULL, NULL, NULL, ReceiveThread, NULL);

    if (!NT_SUCCESS(status)) {
        KdPrint(("Failed to create receive thread.\n"));
    }

    // 创建发送线程
    HANDLE sendThreadHandle;
    status = PsCreateSystemThread(&sendThreadHandle, THREAD_ALL_ACCESS, NULL, NULL, NULL, SendThread, NULL);

    if (!NT_SUCCESS(status)) {
        KdPrint(("Failed to create send thread.\n"));
    }

    // 在初始化中创建一个事件，用于通知线程退出
    KeInitializeEvent(&g_ExitEvent, NotificationEvent, FALSE);

    return STATUS_SUCCESS;
}

// 驱动程序卸载
VOID UnloadDriver(PDRIVER_OBJECT pDriverObject) {
    // 通知线程退出
    KeSetEvent(&g_ExitEvent, 0, FALSE);

    // 等待线程退出
    NTSTATUS status = ZwWaitForSingleObject(&receiveThreadHandle, FALSE, NULL);
    if (NT_SUCCESS(status)) {
        KdPrint(("Receive thread exited.\n"));
    } else {
        KdPrint(("Failed to wait for receive thread exit.\n"));
    }

    status = ZwWaitForSingleObject(&sendThreadHandle, FALSE, NULL);
    if (NT_SUCCESS(status)) {
        KdPrint(("Send thread exited.\n"));
    } else {
        KdPrint(("Failed to wait for send thread exit.\n"));
    }

    // 关闭命名管道
    ZwClose(g_pPipeFileObject);

    KdPrint(("Driver unloaded.\n");
}

extern "C" NTSTATUS
DriverEntry(
    _In_ PDRIVER_OBJECT   DriverObject,
    _In_ PUNICODE_STRING  RegistryPath
)
{
    UNREFERENCED_PARAMETER(RegistryPath);

    DriverObject->DriverUnload = UnloadDriver;

    return STATUS_SUCCESS;
}
